# **Colon Language Interpreter**

## **Module Overview**

### **1. Main Module (`Main.hs`)**

- **Imports**:
    - `Types` — содержит определения типов `Stack`, `Dict`, `Cmd`, `Program`, `Result`, и `Error`.
    - `Lang` — содержит логику выполнения команд и программ.
    - `Data.Map` (с псевдонимом `Map`) — используется для хранения пользовательских определений.
    - `Data.List` и `Data.Char` — для работы со строками.
    - `Debug.Trace` — для отладки.

#### **Key Functions**

1. **`tokenize`**
   Разбивает входную строку на список токенов:
    - Распознаёт строки в кавычках (`."строка"`).
    - Удаляет пробелы и переносы строк.
    - Выводит отладочные сообщения через `trace`.

2. **`parseCommand`**
   Парсит входную строку в список команд (`[Cmd]`):
    - Распознаёт определение слов (`: word definition ;`).
    - Вызывает `parseTokens` для обработки остальных токенов.

3. **`parseTokens`**
   Преобразует список токенов в список команд:
    - Распознаёт числа, строки, и слова.
    - Генерирует соответствующие команды (`Number`, `PrintString`, `Word`).

4. **`formatStack`**
   Форматирует стек для удобного вывода.

5. **`repl`**
   Реализует REPL (read-eval-print-loop):
    - Вводит программу от пользователя.
    - Парсит команды и выполняет их.
    - Обрабатывает ошибки и отображает текущий стек.

6. **`main`**
   Точка входа в программу. Запускает REPL с пустым стеком и словарём.

---

### **2. Language Module (`Lang.hs`)**

- **Imports**:
    - `Types` — для работы с командами, программами, и типами ошибок.
    - `Debug.Trace` — для отладки.

#### **Key Functions**

1. **`executeCmd`**
   Выполняет одну команду (`Cmd`):
    - Арифметические операции (`+`, `-`, `*`, `/`) с обработкой ошибок стека и деления на ноль.
    - Операции со стеком (`dup`, `drop`, `swap`, `over`).
    - Вывод на экран (`.`, `cr`, `emit`).
    - Ввод символа (`key`).
    - Определение пользовательских слов (`Define`).
    - Выполнение пользовательских слов.

2. **`executeProgram`**
   Выполняет список команд:
    - Обрабатывает каждую команду рекурсивно через `processCommands`.
    - Обрабатывает ошибки выполнения.

---

### **3. Types Module (`Types.hs`)**

#### **Key Definitions**

1. **`type Stack`**
   Определён как `[Int]`. Представляет стек чисел.

2. **`newtype Dict`**
   Представляет словарь пользовательских определений:
   ```haskell
   newtype Dict = Dict { getDefinitions :: Map.Map String Program }
   ```

3. **`data Cmd`**
   Представляет команды:
    - `Number Int` — команда для числа.
    - `Word String` — команда для слова.
    - `PrintString String` — вывод строки.
    - `Define String Program` — определение нового слова.

4. **`data Program`**
   Список команд:
   ```haskell
   data Program = Program [Cmd]
   ```

5. **`data Result`**
   Результат выполнения программы:
    - `Ok Stack` — успешное выполнение с новым стеком.
    - `RuntimeError Error` — ошибка выполнения.

6. **`data Error`**
   Возможные ошибки:
    - `StackUnderflow` — недостаточно элементов в стеке.
    - `DivisionByZero` — деление на ноль.
    - `UnknownWord String` — неизвестное слово.

---

## **Code Execution Flow**

1. Пользователь вводит программу в `REPL`.
2. `tokenize` разбивает строку на токены.
3. `parseCommand` преобразует токены в список команд (`[Cmd]`).
4. `executeProgram` выполняет команды, обрабатывая ошибки.
5. Стек и результаты выводятся на экран через `formatStack`.

---

## **Example**

### Input

```colon
: square dup * ;
5 square .
```

### Execution

1. **Tokenization**:
   ```haskell
   [":", "square", "dup", "*", ";", "5", "square", "."]
   ```

2. **Parsing**:
   ```haskell
   [Define "square" (Program [Word "dup", Word "*"]), Number 5, Word "square", Word "."]
   ```

3. **Execution**:
    - Определение `square` как `dup *`.
    - Выполнение `5 square .`:
        - `5 -> 5 5` (dup)
        - `5 5 -> 25` (*)
        - `25` выводится на экран.

### Output
```text
25
| <- Top
```

---

## Планы на следующий этап

1. Реализация цикла `BEGIN UNTIL` - 1 балл;
2. Проверка комментариев про стек (анализ операций со стеком для выявления ошибок) - 3 балла;
3. Добавление массивов - 2 балла;
4. Реализация пошаговой отладки с возможностью получения текущего состояния стека, памяти, словаря и других данных - 3 балла;
5. Улучшение REPL с использованием библиотеки `readline` (например, история ввода, автодополнение) - 5 баллов;
6. Реализация LSP с хотя бы одной функцией - 6 баллов;
7. Поддержка арифметических операций над числами с плавающей запятой - 2 балла.

---

## Второй этап

### Были добавлены:
   - Проверка комментариев про стек (анализ операций со стеком для выявления ошибок)
   - Поддержка арифметических операций над числами с плавающей запятой
   - Доработаны сравнения и комментарии
